# -*- coding: utf-8 -*-
"""1stinningswinpob.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1SN0y6wX6FvviIe2CTeAc37dhhQNdklDv
"""

import pandas as pd
import numpy as np


# In[2]:


deliveries=pd.read_csv('/content/deliveries.csv')
match_details=pd.read_csv('/content/match_details.csv')
venue=pd.read_csv('/content/venue.csv')
pd.set_option('display.max_columns',None)


# In[3]:


deliveries['total_runs'] = deliveries['runs_off_bat'] + deliveries['extras']


# ##### Since we are only doing it for the 2nd inniings we need the total score from innings 1

# In[4]:


total=deliveries.groupby(['match_id','innings'])['total_runs'].sum().reset_index()


# In[5]:


total.head()


# In[6]:


total_df=total[total['innings'] == 2]


# In[7]:


results=match_details.merge(total_df[['match_id','total_runs']],on='match_id')


# In[8]:


res=results.merge(venue[['index','city']], left_on ='venueID',right_on='index')


# ### Steps
# #####  1. Lets keep only the current ipl teams
# #####  2.replace some teams with their new names
# #####  3. remove records where D/l is applied
# #####  4. remove records where super over happend

# In[9]:


res1=res.copy()


# In[10]:


res1['team1']=res1['team1'].str.replace('Kings XI Punjab','Punjab Kings')
res1['team2']=res1['team2'].str.replace('Kings XI Punjab','Punjab Kings')
res1['team1']=res1['team1'].str.replace('Delhi Daredevils','Delhi Capitals')
res1['team2']=res1['team2'].str.replace('Delhi Daredevils','Delhi Capitals')
res1['team1']=res1['team1'].str.replace('Deccan Chargers','Sunrisers Hyderabad')
res1['team2']=res1['team2'].str.replace('Deccan Chargers','Sunrisers Hyderabad')


# In[11]:


teams=['Kolkata Knight Riders','Royal Challengers Bangalore','Chennai Super Kings','Rajasthan Royals','Mumbai Indians','Sunrisers Hyderabad','Delhi Capitals','Punjab Kings','Lucknow Super Giants','Gujarat Titans']


# In[12]:


matches=res1[res1['team1'].isin(teams)]
matches=res1[res1['team2'].isin(teams)]


# In[13]:


matches=matches[matches['method'] != 'D/L']


# In[14]:


matches=matches[matches['outcome'] != 'no result']


# In[15]:


matches=matches[['match_id','total_runs','city','winner']]


# In[16]:


super_df=matches.merge(deliveries,on='match_id')


# In[17]:


super1=super_df.copy()


# In[18]:


super1['batting_team']=super1['batting_team'].str.replace('Kings XI Punjab','Punjab Kings')
super1['bowling_team']=super1['bowling_team'].str.replace('Kings XI Punjab','Punjab Kings')
super1['batting_team']=super1['batting_team'].str.replace('Delhi Daredevils','Delhi Capitals')
super1['bowling_team']=super1['bowling_team'].str.replace('Delhi Daredevils','Delhi Capitals')
super1['batting_team']=super1['batting_team'].str.replace('Deccan Chargers','Sunrisers Hyderabad')
super1['bowling_team']=super1['bowling_team'].str.replace('Deccan Chargers','Sunrisers Hyderabad')
super1['winner']=super1['winner'].str.replace('Kings XI Punjab','Punjab Kings')
super1['winner']=super1['winner'].str.replace('Delhi Daredevils','Delhi Capitals')
super1['winner']=super1['winner'].str.replace('Deccan Chargers','Sunrisers Hyderabad')


# In[19]:


super1=super1[super1['batting_team'].isin(teams)]
super1=super1[super1['bowling_team'].isin(teams)]
super1=super1[super1['winner'].isin(teams)]


# In[23]:


super1.head()


# In[24]:


super1=super1[super1['innings'] == 1]


# In[26]:


super1.rename(columns={'total_runs_x':'2ndinnscore','total_runs_y':'runs'},inplace=True)


# In[27]:


super1=super1[['match_id','batting_team','bowling_team','winner','player_dismissed','city','ball','runs','2ndinnscore']]


# In[28]:


super2=super1.copy()


# ### what we need ?
# ##### 1. over_no
# ##### 2. ball_no
# ##### 3. curent_score
# ##### 4. crr
# ##### 5. rrr
# ##### 6.score_last_five
# ##### 6.wickets fallen
# ##### 6.wickets remaining
# ##### 7.result
# 

# In[29]:


super2['over_no']=super2['ball'].apply(lambda x: str(x).split('.')[0])
super2['ball_no']=super2['ball'].apply(lambda x: str(x).split('.')[1])


# In[30]:


inn2=super2.groupby('match_id')['runs'].sum().reset_index()


# In[31]:


super2=super2.merge(inn2,on='match_id')


# In[32]:


super2['current_score']=super2.groupby('match_id')['runs_x'].cumsum()


# In[33]:


super2['balls_bowled']=(super2['over_no'].astype('int')*6) + (super2['ball_no'].astype('int'))


# In[34]:


super2['balls_left']= 126 - super2['balls_bowled']


# In[35]:


super2['balls_left']=super2['balls_left'].apply(lambda x:0 if x<0 else x)


# ##### Replace the nan with 0 values

# In[36]:


super2['player_dismissed']=super2['player_dismissed'].fillna(0)


# In[37]:


super2['player_dismissed']=super2['player_dismissed'].apply(lambda x:0 if x== 0 else 1)


# In[38]:


super2['wickets_fallen']=super2.groupby('match_id')['player_dismissed'].cumsum()


# In[39]:


super2['wickets_remaining']= 10 - super2['wickets_fallen']


# In[40]:


super2['crr']= round((super2['current_score']*6)/super2['balls_bowled'],2)


# In[41]:


matchez=super2.groupby('match_id')
scores_lastfive=[]
for i in super2['match_id'].unique():
    scores_lastfive.extend(matchez.get_group(i).rolling(window=30)['runs_x'].sum().values.tolist())
    
super2['score_lastfive'] = scores_lastfive


# In[42]:


super3=super2.dropna()


# In[43]:


super3.head()


# In[44]:


super3.rename(columns={'runs_y':'scored_runs'},inplace=True)


# In[45]:


def result(row):
    return 1 if row['batting_team'] == row['winner'] else 0


super3['result'] = super3.apply(result,axis=1)


# In[46]:


super4=super3[['batting_team','bowling_team','city','balls_left','wickets_fallen','crr','score_lastfive','result']]


# In[47]:


super4['score_lastfive']=super4['score_lastfive'].astype('int')


# In[48]:


X = super4.iloc[:,:-1]
y = super4.result
from sklearn.model_selection import train_test_split
x_train,x_test,y_train,y_test = train_test_split(X,y,test_size=0.3,random_state=1)


# In[49]:


from sklearn.compose import ColumnTransformer
from sklearn.preprocessing import OneHotEncoder
from sklearn.pipeline import Pipeline
from sklearn.preprocessing import StandardScaler

trf2 = ColumnTransformer([
    ('trf2',OneHotEncoder(sparse=False,drop='first'),['batting_team','bowling_team','city'])
]
,remainder='passthrough')


pipe = Pipeline(steps=[
    ('step1', trf2),
    ('step2', StandardScaler())
])

train_x=pipe.fit_transform(x_train)


# In[50]:


x_test=trf2.fit_transform(x_test)
x_train=trf2.fit_transform(x_train)
sc=StandardScaler().fit(x_train)
test_x=sc.transform(x_test)

import tensorflow as tf
from tensorflow import keras 
from tensorflow.keras.models import Sequential
from tensorflow.keras import layers,models
from keras.layers import Dense,Activation,Dropout
from keras.activations import sigmoid,relu

def create_model(layers,activation,dropout):
    model=Sequential()
    for i,nodes in enumerate(layers):
        if i==0:
            model.add(Dense(nodes,input_dim=train_x.shape[1]))
            model.add(Activation(activation))
            model.add(Dropout(dropout))
            
        else:
            model.add(Dense(nodes))
            model.add(Activation(activation))
            model.add(Dropout(dropout))
            
        model.add(Dense(1,kernel_initializer='glorot_uniform',activation='sigmoid'))    
        model.compile(optimizer='adam',loss='binary_crossentropy',metrics=["accuracy"])
        
      
    return model 



from keras.wrappers.scikit_learn import KerasClassifier
from sklearn.model_selection import GridSearchCV





model=KerasClassifier(build_fn=create_model,verbose=0)
layers=[[25,30],[35,40],[45,15],[40,20],[50,20]]
activations=['relu']
dropout=[0.1,0.2]

params=dict(layers=layers,activation=activations,dropout=dropout,batch_size=[128],epochs=[30])
grid=GridSearchCV(estimator=model,param_grid=params,cv=5,error_score='raise',verbose=2)

grid_result=grid.fit(train_x,y_train)




print(grid_result.best_score_,grid_result.best_params_)

model = Sequential()
  
model.add(Dense(52, activation='relu'))
model.add(Dropout(0.1))
  
model.add(Dense(45, activation='relu'))
model.add(Dropout(0.1))
  
model.add(Dense(15, activation='relu'))
model.add(Dropout(0.5))
  
model.add(Dense(1))
  
model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])


model.fit(x=train_x, y=y_train, epochs=300, 
          validation_split=0.2,batch_size=128)

y_pred = model.predict(test_x)
y_pred = (y_pred > 0.5)

# Making the Confusion Matrix
from sklearn.metrics import confusion_matrix
cm = confusion_matrix(y_test, y_pred)

# Calculate the Accuracy
from sklearn.metrics import accuracy_score
score=accuracy_score(y_pred,y_test)


import seaborn as sns
sns.heatmap(cm,annot=True,fmt='d')
print(score)

import pickle
pickle.dump(model ,open('model1stinnings.pkl','wb'))